<!DOCTYPE html>
<html lang="tr">
<head>
  <link rel="manifest" href="manifest.json">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Ù¾Ø±Ù‘Ø§Ù† Ù‚ÙˆØ´ - PerrÃ¢n KuÅŸ</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Amiri:wght@400;700&family=Scheherazade+New:wght@400;700&family=Fredoka:wght@400;600;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

  html, body {
    touch-action: manipulation;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    overscroll-behavior: none;
    position: fixed;
    width: 100%;
    height: 100%;
  }

  body {
    background: #1a0a2e;
    background-image: 
      radial-gradient(ellipse at 20% 50%, rgba(139, 69, 19, 0.15) 0%, transparent 50%),
      radial-gradient(ellipse at 80% 50%, rgba(0, 80, 120, 0.15) 0%, transparent 50%);
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    min-height: -webkit-fill-available;
    font-family: 'Amiri', serif;
    overflow: hidden;
    user-select: none;
    padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
  }

  #gameWrapper {
    position: relative;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 
      0 0 60px rgba(212, 175, 55, 0.2),
      0 0 120px rgba(212, 175, 55, 0.05),
      0 20px 60px rgba(0, 0, 0, 0.6);
    border: 3px solid #D4AF37;
    max-width: 100vw;
    max-height: 100vh;
    max-height: -webkit-fill-available;
    touch-action: none;
  }

  canvas {
    display: block;
    cursor: pointer;
    touch-action: none;
    max-width: 100vw;
    max-height: 100vh;
    max-height: -webkit-fill-available;
  }

  #uiOverlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 10;
  }

  #score {
    position: absolute;
    top: 30px;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Scheherazade New', serif;
    font-size: 56px;
    color: #D4AF37;
    text-shadow: 
      2px 2px 0 #000,
      -1px -1px 0 #000,
      1px -1px 0 #000,
      -1px 1px 0 #000,
      0 0 20px rgba(212, 175, 55, 0.5),
      0 0 40px rgba(212, 175, 55, 0.2);
    z-index: 20;
    transition: transform 0.1s;
  }

  #score.bump { transform: translateX(-50%) scale(1.3); }

  .screen-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    pointer-events: auto;
    z-index: 30;
    transition: opacity 0.3s;
  }

  #startScreen {
    background: rgba(10, 5, 20, 0.5);
    backdrop-filter: blur(2px);
  }

  #gameOverScreen {
    background: rgba(10, 5, 20, 0.6);
    backdrop-filter: blur(6px);
    display: none;
  }

  .ottoman-title {
    font-family: 'Scheherazade New', serif;
    font-size: 42px;
    font-weight: 700;
    color: #D4AF37;
    text-shadow: 0 0 30px rgba(212, 175, 55, 0.4), 2px 2px 4px rgba(0,0,0,0.8);
    margin-bottom: 4px;
    text-align: center;
    direction: rtl;
  }

  .ottoman-subtitle-latin {
    font-family: 'Amiri', serif;
    font-size: 20px;
    color: #C9A84C;
    letter-spacing: 6px;
    text-transform: uppercase;
    margin-bottom: 24px;
  }

  .subtitle {
    font-family: 'Amiri', serif;
    font-size: 16px;
    color: rgba(212, 175, 55, 0.7);
    margin-top: 24px;
    animation: pulse 2s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 1; }
  }

  .game-over-title {
    font-family: 'Scheherazade New', serif;
    font-size: 36px;
    font-weight: 700;
    color: #C0392B;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 20px rgba(192, 57, 43, 0.3);
    margin-bottom: 24px;
  }

  .score-panel {
    background: linear-gradient(145deg, rgba(30, 15, 50, 0.9), rgba(20, 10, 35, 0.95));
    border: 2px solid #D4AF37;
    border-radius: 12px;
    padding: 24px 48px;
    text-align: center;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5), inset 0 1px 0 rgba(212,175,55,0.2);
    position: relative;
  }

  .score-panel::before {
    content: 'âœ¦';
    position: absolute;
    top: -12px;
    left: 50%;
    transform: translateX(-50%);
    color: #D4AF37;
    font-size: 20px;
  }

  .score-panel .label {
    font-size: 14px;
    color: #C9A84C;
    font-family: 'Amiri', serif;
    margin-bottom: 8px;
    letter-spacing: 4px;
  }

  .score-panel .value {
    font-size: 40px;
    color: #D4AF37;
    font-family: 'Scheherazade New', serif;
    font-weight: 700;
    text-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
  }

  .score-panel .best-label {
    font-size: 12px;
    color: #8B7355;
    font-family: 'Amiri', serif;
    margin-top: 16px;
    margin-bottom: 6px;
    letter-spacing: 3px;
  }

  .score-panel .best-value {
    font-size: 24px;
    color: #90EE90;
    font-family: 'Scheherazade New', serif;
    font-weight: 700;
  }

  .new-best {
    color: #E74C3C !important;
    animation: glow 0.5s ease-in-out infinite alternate;
  }

  @keyframes glow {
    from { text-shadow: 0 0 5px rgba(231, 76, 60, 0.3); }
    to { text-shadow: 0 0 20px rgba(231, 76, 60, 0.8); }
  }

  .medal { font-size: 48px; margin-bottom: 16px; }

  .restart-hint {
    font-size: 14px;
    color: rgba(212,175,55,0.5);
    margin-top: 24px;
    font-family: 'Amiri', serif;
    animation: pulse 2s ease-in-out infinite;
  }

  .anka-icon {
    font-size: 72px;
    margin-bottom: 12px;
    animation: float 3s ease-in-out infinite;
    filter: drop-shadow(0 0 20px rgba(212, 175, 55, 0.4));
  }

  @keyframes float {
    0%, 100% { transform: translateY(0) rotate(-3deg); }
    50% { transform: translateY(-15px) rotate(3deg); }
  }

  .difficulty-bar {
    display: flex;
    gap: 8px;
    margin-top: 16px;
    align-items: center;
  }

  .difficulty-bar span {
    font-size: 14px;
    color: #C9A84C;
    font-family: 'Amiri', serif;
  }

  .diff-btn {
    pointer-events: auto;
    padding: 6px 16px;
    border: 1px solid #8B7355;
    border-radius: 6px;
    background: transparent;
    color: #C9A84C;
    font-family: 'Amiri', serif;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s;
  }

  .diff-btn:hover {
    border-color: #D4AF37;
    color: #D4AF37;
    box-shadow: 0 0 10px rgba(212,175,55,0.2);
  }

  .diff-btn.active {
    background: linear-gradient(135deg, #D4AF37, #B8860B);
    color: #1a0a2e;
    border-color: #D4AF37;
    font-weight: 700;
    box-shadow: 0 0 15px rgba(212,175,55,0.3);
  }

  .ornament {
    color: #D4AF37;
    font-size: 24px;
    opacity: 0.5;
    margin: 8px 0;
  }

  /* Mobile responsive adjustments */
  @media (max-height: 600px) {
    .anka-icon { font-size: 48px; margin-bottom: 8px; }
    .ottoman-title { font-size: 32px; }
    .ottoman-subtitle-latin { font-size: 16px; margin-bottom: 16px; }
    .subtitle { font-size: 14px; margin-top: 16px; }
    .game-over-title { font-size: 28px; margin-bottom: 16px; }
    .score-panel { padding: 16px 32px; }
    .score-panel .value { font-size: 32px; }
    .medal { font-size: 36px; margin-bottom: 10px; }
    #score { font-size: 42px; top: 20px; }
  }

  @media (max-width: 420px) {
    #gameWrapper { border-width: 2px; border-radius: 0; }
    .ottoman-title { font-size: 34px; }
    .diff-btn { padding: 8px 14px; font-size: 13px; }
  }
</style>
</head>
<body>

<div id="gameWrapper">
  <canvas id="gameCanvas"></canvas>

  <div id="uiOverlay">
    <div id="score">Ù </div>

    <div id="startScreen" class="screen-overlay">
      <div class="anka-icon">ðŸ¦…</div>
      <div class="ottoman-title">Ù¾Ø±Ù‘Ø§Ù† Ù‚ÙˆØ´</div>
      <div class="ottoman-subtitle-latin">PerrÃ¢n KuÅŸ</div>
      <div class="ornament">â—† âœ¦ â—†</div>
      <div class="difficulty-bar">
        <span>Zorluk:</span>
        <button class="diff-btn active" data-diff="easy">Kolay</button>
        <button class="diff-btn" data-diff="normal">Orta</button>
        <button class="diff-btn" data-diff="hard">Zor</button>
      </div>
      <div class="subtitle">BaÅŸlamak iÃ§in dokun ya da boÅŸluÄŸa bas</div>
    </div>

    <div id="gameOverScreen" class="screen-overlay">
      <div class="medal" id="medal"></div>
      <div class="game-over-title">Anka DÃ¼ÅŸtÃ¼!</div>
      <div class="score-panel">
        <div class="label">SKOR</div>
        <div class="value" id="finalScore">0</div>
        <div class="best-label">EN Ä°YÄ°</div>
        <div class="best-value" id="bestScore">0</div>
      </div>
      <div class="restart-hint">Tekrar uÃ§mak iÃ§in dokun</div>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const W = 400;
const H = 640;
canvas.width = W;
canvas.height = H;

// Responsive scaling for mobile
function resizeCanvas() {
  const maxW = window.innerWidth;
  const maxH = window.innerHeight;
  const ratio = W / H;
  let displayW, displayH;

  if (maxW / maxH < ratio) {
    displayW = maxW;
    displayH = maxW / ratio;
  } else {
    displayH = maxH;
    displayW = maxH * ratio;
  }

  canvas.style.width = displayW + 'px';
  canvas.style.height = displayH + 'px';
}

resizeCanvas();
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 100));

const ottomanNumerals = ['Ù ','Ù¡','Ù¢','Ù£','Ù¤','Ù¥','Ù¦','Ù§','Ù¨','Ù©'];
function toOttoman(n) {
  return String(n).split('').map(d => ottomanNumerals[parseInt(d)]).join('');
}

let gameState = 'start';
let score = 0;
let bestScore = 0;
let difficulty = 'easy';
let frameCount = 0;
let shakeTimer = 0;
let flashTimer = 0;

const BASE_DIFFICULTIES = {
  easy:   { gap: 190, speed: 1.8, gravity: 0.14, jump: -4.0, pipeFreq: 130 },
  normal: { gap: 160, speed: 2.2, gravity: 0.18, jump: -4.5, pipeFreq: 105 },
  hard:   { gap: 130, speed: 3.0, gravity: 0.25, jump: -5.2, pipeFreq: 80 }
};

// Progressive difficulty: lerp from base toward hard cap based on score
function getProgressiveSettings() {
  const base = BASE_DIFFICULTIES[difficulty];
  const t = Math.min(score / 50, 1); // fully hard at score 50
  const ease = t * t; // quadratic easing â€” gentle early, steep late
  return {
    gap:      Math.max(80, Math.round(base.gap - ease * 60)),
    speed:    base.speed + ease * 1.8,
    gravity:  base.gravity + ease * 0.12,
    jump:     base.jump - ease * 1.2,
    pipeFreq: Math.max(30, Math.round(base.pipeFreq - ease * 45))
  };
}

let settings = BASE_DIFFICULTIES.easy;

const bird = {
  x: 80, y: H / 2,
  w: 40, h: 30,
  vy: 0, rotation: 0,
  wingTimer: 0, alive: true, tailFlame: 0
};

let pipes = [];
const PIPE_WIDTH = 56;
const GROUND_H = 80;
const groundY = H - GROUND_H;
let groundX = 0;
let particles = [];

let stars = [];
for (let i = 0; i < 40; i++) {
  stars.push({
    x: Math.random() * W,
    y: Math.random() * (H - GROUND_H - 120) + 20,
    size: Math.random() * 2 + 0.5,
    twinkle: Math.random() * Math.PI * 2,
    type: Math.random() > 0.7 ? 'crescent' : 'star'
  });
}

let clouds = [];
for (let i = 0; i < 4; i++) {
  clouds.push({
    x: Math.random() * W * 1.5,
    y: 40 + Math.random() * 120,
    w: 50 + Math.random() * 60,
    speed: 0.15 + Math.random() * 0.2
  });
}

const IZNIK = {
  blue: '#1A5276', turquoise: '#0E6655', red: '#C0392B',
  white: '#FAF0E6', gold: '#D4AF37', darkBlue: '#0B2545', cobalt: '#1B4F72'
};

// ---- DRAWING ----

function drawOttomanSky() {
  const grad = ctx.createLinearGradient(0, 0, 0, groundY);
  if (score < 10) {
    grad.addColorStop(0, '#0B1A3E');
    grad.addColorStop(0.4, '#142952');
    grad.addColorStop(0.8, '#1A3A5C');
    grad.addColorStop(1, '#1E4D6B');
  } else if (score < 20) {
    grad.addColorStop(0, '#1A0A2E');
    grad.addColorStop(0.5, '#2D1B4E');
    grad.addColorStop(1, '#4A2040');
  } else {
    grad.addColorStop(0, '#050510');
    grad.addColorStop(0.5, '#0B0B2A');
    grad.addColorStop(1, '#151535');
  }
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, groundY);

  // Arabesque overlay
  ctx.globalAlpha = 0.03;
  ctx.strokeStyle = IZNIK.gold;
  ctx.lineWidth = 1;
  for (let i = 0; i < W; i += 40) {
    for (let j = 0; j < 120; j += 40) {
      for (let k = 0; k < 8; k++) {
        const a = (k / 8) * Math.PI * 2;
        const a2 = ((k + 3) / 8) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(i + 20 + Math.cos(a) * 18, j + 20 + Math.sin(a) * 18);
        ctx.lineTo(i + 20 + Math.cos(a2) * 18, j + 20 + Math.sin(a2) * 18);
        ctx.stroke();
      }
    }
  }
  ctx.globalAlpha = 1;
}

function drawStars() {
  stars.forEach(s => {
    const tw = Math.sin(frameCount * 0.03 + s.twinkle) * 0.4 + 0.6;
    ctx.globalAlpha = tw * 0.8;
    if (s.type === 'crescent') {
      ctx.fillStyle = IZNIK.gold;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.size * 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = getSkyColor();
      ctx.beginPath();
      ctx.arc(s.x + s.size, s.y - s.size * 0.3, s.size * 1.8, 0, Math.PI * 2);
      ctx.fill();
    } else {
      ctx.fillStyle = IZNIK.gold;
      drawStar8(s.x, s.y, s.size * 0.5, s.size * 1.2);
    }
  });
  ctx.globalAlpha = 1;
}

function getSkyColor() {
  if (score < 10) return '#142952';
  if (score < 20) return '#2D1B4E';
  return '#0B0B2A';
}

function drawStar8(cx, cy, ir, or) {
  ctx.beginPath();
  for (let i = 0; i < 8; i++) {
    const ao = (i / 8) * Math.PI * 2 - Math.PI / 2;
    const ai = ((i + 0.5) / 8) * Math.PI * 2 - Math.PI / 2;
    if (i === 0) ctx.moveTo(cx + Math.cos(ao) * or, cy + Math.sin(ao) * or);
    else ctx.lineTo(cx + Math.cos(ao) * or, cy + Math.sin(ao) * or);
    ctx.lineTo(cx + Math.cos(ai) * ir, cy + Math.sin(ai) * ir);
  }
  ctx.closePath();
  ctx.fill();
}

function drawClouds() {
  ctx.globalAlpha = 0.08;
  ctx.fillStyle = IZNIK.gold;
  clouds.forEach(c => {
    for (let i = 0; i < 5; i++) {
      ctx.beginPath();
      ctx.arc(c.x + (i - 2) * c.w * 0.18, c.y, c.w * (0.3 - Math.abs(i - 2) * 0.04), Math.PI, 0);
      ctx.fill();
    }
  });
  ctx.globalAlpha = 1;
}

function drawMosqueSilhouette() {
  ctx.globalAlpha = 0.06;
  ctx.fillStyle = IZNIK.gold;
  ctx.beginPath(); ctx.arc(200, groundY - 20, 60, Math.PI, 0); ctx.fill();
  ctx.beginPath(); ctx.arc(120, groundY - 10, 30, Math.PI, 0); ctx.fill();
  ctx.beginPath(); ctx.arc(280, groundY - 10, 30, Math.PI, 0); ctx.fill();
  ctx.fillRect(70, groundY - 80, 8, 80);
  ctx.fillRect(322, groundY - 80, 8, 80);
  ctx.beginPath(); ctx.moveTo(74, groundY - 80); ctx.lineTo(70, groundY - 68); ctx.lineTo(78, groundY - 68); ctx.fill();
  ctx.beginPath(); ctx.moveTo(326, groundY - 80); ctx.lineTo(322, groundY - 68); ctx.lineTo(330, groundY - 68); ctx.fill();
  ctx.globalAlpha = 1;
}

function drawOttomanGround() {
  const grad = ctx.createLinearGradient(0, groundY, 0, H);
  grad.addColorStop(0, '#8B4513');
  grad.addColorStop(0.02, '#CD853F');
  grad.addColorStop(0.1, '#DEB887');
  grad.addColorStop(0.3, '#D2B48C');
  grad.addColorStop(1, '#A0522D');
  ctx.fillStyle = grad;
  ctx.fillRect(0, groundY, W, GROUND_H);

  // Ä°znik tile strip
  const tileH = 16, tileW = 20;
  for (let i = -1; i < W / tileW + 2; i++) {
    const tx = ((i * tileW + groundX * 1.5) % (W + tileW * 2)) - tileW;
    const alt = (Math.floor((i + Math.floor(-groundX / tileW)) % 3) + 3) % 3;
    ctx.fillStyle = [IZNIK.cobalt, IZNIK.turquoise, IZNIK.red][alt];
    ctx.fillRect(tx, groundY, tileW - 1, tileH);
    ctx.fillStyle = IZNIK.white;
    ctx.globalAlpha = 0.4;
    ctx.beginPath(); ctx.arc(tx + tileW / 2, groundY + tileH / 2, 3, 0, Math.PI * 2); ctx.fill();
    for (let p = 0; p < 4; p++) {
      const pa = (p / 4) * Math.PI * 2;
      ctx.beginPath();
      ctx.ellipse(tx + tileW / 2 + Math.cos(pa) * 5, groundY + tileH / 2 + Math.sin(pa) * 5, 2, 1, pa, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
  ctx.fillStyle = IZNIK.gold;
  ctx.fillRect(0, groundY, W, 2);
  ctx.fillRect(0, groundY + tileH, W, 1);
}

function drawMinaret(p) {
  const capH = 28, capExtra = 10;

  // Shaft gradient
  const sg = ctx.createLinearGradient(p.x, 0, p.x + PIPE_WIDTH, 0);
  sg.addColorStop(0, '#DEB887'); sg.addColorStop(0.15, '#F5DEB3');
  sg.addColorStop(0.5, '#FAEBD7'); sg.addColorStop(0.85, '#F5DEB3');
  sg.addColorStop(1, '#C9A96E');

  // Top pipe
  ctx.fillStyle = sg;
  ctx.fillRect(p.x, 0, PIPE_WIDTH, p.topH);

  // Band
  ctx.fillStyle = IZNIK.cobalt;
  ctx.fillRect(p.x, p.topH - capH - 6, PIPE_WIDTH, 10);
  ctx.fillStyle = IZNIK.gold; ctx.globalAlpha = 0.6;
  for (let i = 0; i < PIPE_WIDTH; i += 12) {
    ctx.beginPath(); ctx.arc(p.x + i + 6, p.topH - capH - 1, 2, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  drawMinaretCap(p.x - capExtra, p.topH - capH, PIPE_WIDTH + capExtra * 2, capH);

  // Bottom pipe
  ctx.fillStyle = sg;
  ctx.fillRect(p.x, p.bottomY, PIPE_WIDTH, groundY - p.bottomY);

  ctx.fillStyle = IZNIK.cobalt;
  ctx.fillRect(p.x, p.bottomY + capH - 4, PIPE_WIDTH, 10);
  ctx.fillStyle = IZNIK.gold; ctx.globalAlpha = 0.6;
  for (let i = 0; i < PIPE_WIDTH; i += 12) {
    ctx.beginPath(); ctx.arc(p.x + i + 6, p.bottomY + capH + 1, 2, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  drawMinaretCap(p.x - capExtra, p.bottomY, PIPE_WIDTH + capExtra * 2, capH);

  // Mini dome on top
  ctx.fillStyle = '#C0C0C0';
  ctx.beginPath(); ctx.arc(p.x + PIPE_WIDTH / 2, 14, 8, Math.PI, 0); ctx.fill();
  ctx.fillStyle = IZNIK.gold;
  ctx.beginPath(); ctx.arc(p.x + PIPE_WIDTH / 2, 6, 4, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#C0C0C0';
  ctx.beginPath(); ctx.arc(p.x + PIPE_WIDTH / 2 + 1.5, 5.5, 3.2, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = IZNIK.gold; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(p.x + PIPE_WIDTH / 2, 14); ctx.lineTo(p.x + PIPE_WIDTH / 2, 5); ctx.stroke();

  // Shaft highlights
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.fillRect(p.x + 8, 0, 6, p.topH - capH);
  ctx.fillRect(p.x + 8, p.bottomY + capH, 6, groundY - p.bottomY - capH);
}

function drawMinaretCap(x, y, w, h) {
  const grad = ctx.createLinearGradient(x, y, x + w, y);
  grad.addColorStop(0, '#B8860B'); grad.addColorStop(0.3, '#D4AF37');
  grad.addColorStop(0.5, '#F0D060'); grad.addColorStop(0.7, '#D4AF37');
  grad.addColorStop(1, '#B8860B');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.moveTo(x + 3, y); ctx.lineTo(x + w - 3, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + 3);
  ctx.lineTo(x + w, y + h - 3);
  ctx.quadraticCurveTo(x + w, y + h, x + w - 3, y + h);
  ctx.lineTo(x + 3, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - 3);
  ctx.lineTo(x, y + 3);
  ctx.quadraticCurveTo(x, y, x + 3, y);
  ctx.fill();
  ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 1;
  ctx.strokeRect(x + 2, y + 2, w - 4, h - 4);

  // Mini arches
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  const ac = Math.floor(w / 16), aw2 = w / ac;
  for (let i = 0; i < ac; i++) {
    const ax = x + i * aw2 + aw2 * 0.2, aw3 = aw2 * 0.6;
    ctx.beginPath(); ctx.arc(ax + aw3 / 2, y + h - 6, aw3 / 2, Math.PI, 0);
    ctx.lineTo(ax + aw3, y + h - 3); ctx.lineTo(ax, y + h - 3); ctx.fill();
  }
  ctx.fillStyle = 'rgba(255,255,200,0.15)';
  ctx.fillRect(x + 4, y + 3, w * 0.3, h - 6);
}

function drawAnkaBird() {
  ctx.save();
  ctx.translate(bird.x, bird.y);
  ctx.rotate(bird.rotation);
  bird.tailFlame += 0.15;

  // Flame trail
  ctx.globalAlpha = 0.6;
  for (let i = 0; i < 5; i++) {
    const fl = Math.sin(bird.tailFlame + i * 0.8) * 3;
    const fx = -18 - i * 6, fy = fl + i * 0.5, fs = Math.max(0.5, 8 - i * 1.2);
    const fg = ctx.createRadialGradient(fx, fy, 0, fx, fy, fs);
    fg.addColorStop(0, i < 2 ? '#FFD700' : '#FF6B35');
    fg.addColorStop(0.5, i < 2 ? '#FF8C00' : '#FF4500');
    fg.addColorStop(1, 'rgba(255,69,0,0)');
    ctx.fillStyle = fg;
    ctx.beginPath(); ctx.ellipse(fx, fy, fs * 0.7, fs, 0.2, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Shadow
  ctx.globalAlpha = 0.15; ctx.fillStyle = '#000';
  ctx.beginPath(); ctx.ellipse(3, 5, bird.w / 2, bird.h / 2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.globalAlpha = 1;

  // Tail feathers
  ctx.fillStyle = '#8B0000';
  for (let i = 0; i < 3; i++) {
    ctx.save(); ctx.rotate(-0.3 + i * 0.15);
    ctx.beginPath(); ctx.ellipse(-20, 0, 14, 3, 0, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
  }

  // Body
  const bg = ctx.createRadialGradient(-2, -3, 3, 0, 0, bird.w / 2);
  bg.addColorStop(0, '#FF6B35'); bg.addColorStop(0.4, '#E25822');
  bg.addColorStop(0.8, '#C0392B'); bg.addColorStop(1, '#8B0000');
  ctx.fillStyle = bg;
  ctx.beginPath(); ctx.ellipse(0, 0, bird.w / 2, bird.h / 2, 0, 0, Math.PI * 2); ctx.fill();

  // Gold feather pattern
  ctx.globalAlpha = 0.3; ctx.strokeStyle = IZNIK.gold; ctx.lineWidth = 0.8;
  for (let i = 0; i < 5; i++) {
    ctx.beginPath(); ctx.ellipse(-4 + i * 4, 0, 4, bird.h / 2 - 2, 0, 0, Math.PI * 2); ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // Wing
  const wy = Math.sin(bird.wingTimer) * 7;
  const wg = ctx.createRadialGradient(-4, wy, 2, -4, wy, 14);
  wg.addColorStop(0, '#FF8C00'); wg.addColorStop(0.6, '#E25822'); wg.addColorStop(1, '#8B0000');
  ctx.fillStyle = wg;
  ctx.beginPath(); ctx.ellipse(-4, wy - 2, 14, 8, -0.3, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = IZNIK.gold; ctx.lineWidth = 0.8; ctx.globalAlpha = 0.4;
  ctx.beginPath(); ctx.ellipse(-4, wy - 2, 10, 5, -0.3, 0, Math.PI * 2); ctx.stroke();
  ctx.globalAlpha = 1;

  // Head crest
  ctx.fillStyle = '#FFD700';
  ctx.beginPath(); ctx.moveTo(6, -12); ctx.quadraticCurveTo(12, -24, 4, -22);
  ctx.quadraticCurveTo(8, -18, 2, -14); ctx.fill();
  ctx.fillStyle = '#FF8C00';
  ctx.beginPath(); ctx.moveTo(3, -11); ctx.quadraticCurveTo(6, -20, 0, -18);
  ctx.quadraticCurveTo(4, -15, -1, -12); ctx.fill();

  // Eye
  ctx.fillStyle = '#FFD700';
  ctx.beginPath(); ctx.ellipse(10, -4, 6, 6, 0, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#8B0000'; ctx.lineWidth = 1.5; ctx.stroke();
  ctx.fillStyle = '#1a0a2e';
  ctx.beginPath(); ctx.ellipse(11.5, -4, 3, 3.5, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#FF4500'; ctx.globalAlpha = 0.5;
  ctx.beginPath(); ctx.arc(12.5, -5, 1.2, 0, Math.PI * 2); ctx.fill();
  ctx.globalAlpha = 1;

  // Beak
  ctx.fillStyle = '#D4AF37';
  ctx.beginPath(); ctx.moveTo(15, -2); ctx.quadraticCurveTo(28, -4, 26, 0);
  ctx.quadraticCurveTo(28, 4, 15, 4); ctx.closePath(); ctx.fill();
  ctx.strokeStyle = '#B8860B'; ctx.lineWidth = 1; ctx.stroke();

  // Belly glow
  ctx.globalAlpha = 0.2; ctx.fillStyle = '#FFD700';
  ctx.beginPath(); ctx.ellipse(0, 5, 8, 5, 0, 0, Math.PI * 2); ctx.fill();
  ctx.globalAlpha = 1;

  ctx.restore();
}

function drawParticles() {
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    if (p.type === 'ember') {
      const eg = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2);
      eg.addColorStop(0, p.color); eg.addColorStop(1, 'rgba(255,69,0,0)');
      ctx.fillStyle = eg;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2); ctx.fill();
    } else {
      ctx.fillStyle = p.color;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
    }
  });
  ctx.globalAlpha = 1;
}

// ---- GAME LOGIC ----

function resetGame() {
  bird.y = H / 2; bird.vy = 0; bird.rotation = 0; bird.alive = true;
  pipes = []; particles = []; score = 0;
  frameCount = 0; shakeTimer = 0; flashTimer = 0;
  settings = BASE_DIFFICULTIES[difficulty];
  document.getElementById('score').textContent = 'Ù ';
}

let canRestart = false;

function flap() {
  if (gameState === 'start') {
    resetGame(); gameState = 'playing';
    document.getElementById('startScreen').style.display = 'none';
    document.getElementById('gameOverScreen').style.display = 'none';
    bird.vy = settings.jump; spawnFlapParticles(); return;
  }
  if (gameState === 'playing') {
    bird.vy = settings.jump; bird.wingTimer = 0; spawnFlapParticles(); return;
  }
  if (gameState === 'dead' && canRestart) {
    canRestart = false;
    gameState = 'start';
    document.getElementById('gameOverScreen').style.display = 'none';
    document.getElementById('startScreen').style.display = 'flex';
  }
}

function spawnFlapParticles() {
  for (let i = 0; i < 6; i++) {
    particles.push({
      x: bird.x - 10, y: bird.y + 6,
      vx: -Math.random() * 2.5 - 0.5, vy: Math.random() * 2 - 1,
      size: Math.random() * 3 + 1, life: 1,
      color: ['#FFD700', '#FF8C00', '#FF4500'][Math.floor(Math.random() * 3)],
      type: 'ember'
    });
  }
}

function spawnDeathParticles() {
  for (let i = 0; i < 25; i++) {
    const a = Math.random() * Math.PI * 2, s = Math.random() * 4 + 2;
    particles.push({
      x: bird.x, y: bird.y,
      vx: Math.cos(a) * s, vy: Math.sin(a) * s,
      size: Math.random() * 4 + 2, life: 1,
      color: ['#FFD700', '#FF8C00', '#FF4500', '#C0392B', '#8B0000'][Math.floor(Math.random() * 5)],
      type: Math.random() > 0.5 ? 'ember' : 'normal'
    });
  }
}

function spawnScoreParticles(x, y) {
  for (let i = 0; i < 10; i++) {
    particles.push({
      x, y: y + Math.random() * 30 - 15,
      vx: Math.random() * 2 - 1, vy: -Math.random() * 3 - 1,
      size: Math.random() * 3 + 1, life: 1, color: IZNIK.gold, type: 'ember'
    });
  }
}

function die() {
  if (!bird.alive) return;
  bird.alive = false; gameState = 'dying';
  shakeTimer = 15; flashTimer = 6;
  spawnDeathParticles();
  const isNewBest = score > bestScore;
  if (isNewBest) bestScore = score;
  setTimeout(() => { gameState = 'dead'; showGameOver(isNewBest); }, 800);
}

function showGameOver(isNewBest) {
  document.getElementById('gameOverScreen').style.display = 'flex';
  document.getElementById('finalScore').textContent = score;
  document.getElementById('bestScore').textContent = bestScore;
  const be = document.getElementById('bestScore');
  be.classList.toggle('new-best', isNewBest);
  // Prevent accidental instant restart
  canRestart = false;
  setTimeout(() => { canRestart = true; }, 500);
  const me = document.getElementById('medal');
  if (score >= 40) me.textContent = 'ðŸ‘‘';
  else if (score >= 30) me.textContent = 'ðŸ†';
  else if (score >= 20) me.textContent = 'ðŸ•Œ';
  else if (score >= 10) me.textContent = 'â­';
  else if (score >= 5) me.textContent = 'â˜ªï¸';
  else me.textContent = 'ðŸ¦…';
}

function update() {
  frameCount++;
  clouds.forEach(c => { c.x -= c.speed; if (c.x < -c.w) c.x = W + c.w; });

  if (gameState !== 'playing' && gameState !== 'dying') {
    bird.y = H / 2 + Math.sin(frameCount * 0.03) * 18;
    bird.wingTimer += 0.12;
    return;
  }

  bird.vy += settings.gravity;
  bird.y += bird.vy;
  bird.wingTimer += bird.vy < 0 ? 0.3 : 0.08;

  if (bird.vy < 0) bird.rotation = Math.max(-0.4, bird.rotation - 0.08);
  else bird.rotation = Math.min(Math.PI / 3, bird.rotation + 0.012);

  if (gameState === 'dying') {
    bird.vy += settings.gravity;
    if (bird.y > groundY - bird.h / 2) { bird.y = groundY - bird.h / 2; bird.vy = 0; }
    updateParticles(); return;
  }

  groundX -= settings.speed;
  if (groundX <= -24) groundX += 24;

  if (frameCount % settings.pipeFreq === 0) {
    const minT = 70, maxT = groundY - settings.gap - 70;
    if (maxT > minT) {
      const topH = minT + Math.random() * (maxT - minT);
      pipes.push({ x: W + 10, topH, bottomY: topH + settings.gap, scored: false, speed: settings.speed });
    }
  }

  pipes.forEach(p => {
    p.x -= p.speed || settings.speed;
    if (!p.scored && p.x + PIPE_WIDTH < bird.x) {
      p.scored = true; score++;
      settings = getProgressiveSettings(); // difficulty ramps up!
      document.getElementById('score').textContent = toOttoman(score);
      const el = document.getElementById('score');
      el.classList.add('bump'); setTimeout(() => el.classList.remove('bump'), 100);
      spawnScoreParticles(p.x + PIPE_WIDTH, (p.topH + p.bottomY) / 2);
    }
  });
  pipes = pipes.filter(p => p.x + PIPE_WIDTH > -10);

  const bw = bird.w * 0.35, bh = bird.h * 0.35;
  if (bird.y + bh > groundY || bird.y - bh < 0) { die(); return; }
  for (const p of pipes) {
    if (bird.x + bw > p.x && bird.x - bw < p.x + PIPE_WIDTH) {
      if (bird.y - bh < p.topH || bird.y + bh > p.bottomY) { die(); return; }
    }
  }
  updateParticles();
  if (shakeTimer > 0) shakeTimer--;
  if (flashTimer > 0) flashTimer--;
}

function updateParticles() {
  particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.02; p.size = Math.max(0, p.size * 0.985); });
  particles = particles.filter(p => p.life > 0 && p.size > 0.1);
}

function render() {
  ctx.save();
  if (shakeTimer > 0) {
    const i = shakeTimer * 0.8;
    ctx.translate((Math.random() - 0.5) * i, (Math.random() - 0.5) * i);
  }
  drawOttomanSky(); drawStars(); drawClouds(); drawMosqueSilhouette();
  pipes.forEach(p => drawMinaret(p));
  drawOttomanGround(); drawParticles(); drawAnkaBird();
  if (flashTimer > 0) {
    ctx.globalAlpha = flashTimer / 6 * 0.4;
    ctx.fillStyle = '#FFD700'; ctx.fillRect(0, 0, W, H); ctx.globalAlpha = 1;
  }
  ctx.restore();
}

function gameLoop() { update(); render(); requestAnimationFrame(gameLoop); }

// ---- INPUT ----
document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'ArrowUp') { e.preventDefault(); flap(); }
});
canvas.addEventListener('click', e => { e.preventDefault(); flap(); });

// Mobile touch â€” handle on wrapper for bigger touch area
const wrapper = document.getElementById('gameWrapper');
wrapper.addEventListener('touchstart', e => {
  // Don't intercept difficulty button touches
  if (e.target.classList.contains('diff-btn')) return;
  e.preventDefault();
  e.stopPropagation();
  flap();
}, { passive: false });

// Prevent all unwanted mobile behaviors
document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
document.addEventListener('gesturestart', e => e.preventDefault());
document.addEventListener('gesturechange', e => e.preventDefault());
document.addEventListener('gestureend', e => e.preventDefault());
document.addEventListener('contextmenu', e => e.preventDefault());

// Prevent double-tap zoom on iOS
let lastTouchEnd = 0;
document.addEventListener('touchend', e => {
  const now = Date.now();
  if (now - lastTouchEnd <= 300) e.preventDefault();
  lastTouchEnd = now;
}, { passive: false });

document.querySelectorAll('.diff-btn').forEach(btn => {
  btn.addEventListener('click', e => {
    e.stopPropagation();
    e.stopImmediatePropagation();
    e.preventDefault();
    document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    difficulty = btn.dataset.diff;
    settings = BASE_DIFFICULTIES[difficulty];
  });
});

gameLoop();
</script>
</body>
</html>
